/*
 * UAPI
 *
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_web_tomarkdown_async_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWebTomarkdownAsyncStatusError {
    Status404(models::GetWebTomarkdownAsyncStatus404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_webparse_extractimages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWebparseExtractimagesError {
    Status400(models::GetImageTobase64400Response),
    Status500(models::GetWebparseExtractimages500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_webparse_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWebparseMetadataError {
    Status400(models::GetImageTobase64400Response),
    Status500(models::GetWebparseMetadata500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_web_tomarkdown_async`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostWebTomarkdownAsyncError {
    Status400(models::PostWebTomarkdownAsync400Response),
    UnknownValue(serde_json::Value),
}


/// 提交了URL转Markdown任务后，想知道处理进度和结果？这个接口可以帮你实时追踪。  ## 功能概述  通过之前提交任务时获得的任务ID，你可以查询该任务的当前状态、处理进度以及最终结果。任务结果会在缓存中保存30分钟，期间可以重复查询，非常方便。  任务有五种状态：等待处理（pending）时进度为0%；处理中（processing）时进度在10-90%之间；已完成（completed）时进度为100%并返回Markdown内容；失败（failed）时会返回错误信息；超时（timeout）表示任务处理时间超过60秒已被取消。建议采用指数退避策略进行轮询，初始延迟1秒，每次延迟增加20%，最大延迟5秒。当状态为已完成、失败或超时时停止轮询。  系统会自动管理任务生命周期，单个任务最长处理时间为60秒，任务结果保存30分钟后自动清理，每5分钟清理一次过期任务。  ## 任务状态说明  | 状态 | 说明 | 进度 | 轮询建议 | |------|------|------|----------| | `pending` | 等待处理 | 0% | 立即开始轮询 | | `processing` | 处理中 | 10-90% | 每2-5秒轮询一次 | | `completed` | 已完成 | 100% | 停止轮询，获取结果 | | `failed` | 失败 | 100% | 停止轮询，查看错误信息 | | `timeout` | 超时 | 100% | 停止轮询，任务已取消 |
pub async fn get_web_tomarkdown_async_status(configuration: &configuration::Configuration, task_id: &str) -> Result<models::GetWebTomarkdownAsyncStatus200Response, Error<GetWebTomarkdownAsyncStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_task_id = task_id;

    let uri_str = format!("{}/web/tomarkdown/async/{task_id}", configuration.base_path, task_id=crate::apis::urlencode(p_path_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetWebTomarkdownAsyncStatus200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetWebTomarkdownAsyncStatus200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWebTomarkdownAsyncStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 想一次性“打包”一个网页上的所有图片吗？这个接口可以帮你实现。  ## 功能概述 你提供一个网页的URL，我们会访问该页面，解析其HTML内容，并提取出所有 `<img>` 标签中的图片链接，然后将这些链接列表返回给你。非常适合用于制作图片采集器或素材下载工具。
pub async fn get_webparse_extractimages(configuration: &configuration::Configuration, url: &str) -> Result<models::GetWebparseExtractimages200Response, Error<GetWebparseExtractimagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_url = url;

    let uri_str = format!("{}/webparse/extractimages", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("url", &p_query_url.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetWebparseExtractimages200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetWebparseExtractimages200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWebparseExtractimagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 当你在应用中需要展示一个链接的预览时（就像微信或Telegram里那样），这个接口能帮你轻松获取所需信息。  ## 功能概述 你提供一个网页的URL，我们会抓取并解析它的 `<head>` 部分，提取出关键的元数据（Metadata），如页面标题（Title）、描述（Description）、关键词（Keywords）以及网站图标（Favicon）等。
pub async fn get_webparse_metadata(configuration: &configuration::Configuration, url: &str) -> Result<models::GetWebparseMetadata200Response, Error<GetWebparseMetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_url = url;

    let uri_str = format!("{}/webparse/metadata", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("url", &p_query_url.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetWebparseMetadata200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetWebparseMetadata200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWebparseMetadataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 想要将复杂的网页转换为结构清晰的Markdown？这个接口采用异步处理模式，特别适合处理大型网页、复杂网站或需要长时间处理的转换任务。  ## 功能概述  > [!VIP] >本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  UAPI Pro平台推出的异步网页转Markdown API能够将任意网页URL转换为结构清晰、格式优美的Markdown文本。提交任务后立即返回任务ID，不会阻塞客户端等待。您可以通过任务ID实时查询转换进度和处理状态，支持长达60秒的处理时间，轻松应对大型网站、需要JS渲染的单页应用等复杂页面。任务结果会缓存30分钟，期间可重复查询，过期任务自动清理无需手动管理。  此API采用先进算法，自动识别并抓取网页主体内容，精准剔除广告、导航栏、页眉页脚等无关元素。完美保留原文的格式，包括标题、列表、代码块、表格、引用、图片等，并输出为兼容性强的GitHub Flavored Markdown (GFM) 格式。同时会自动解析并提取文章标题、作者、发布日期、站点名称等关键元数据，并将其格式化为标准的YAML Front Matter，方便后续处理和CMS集成。  ## 使用流程  调用本接口提交URL转换任务后，会立即获得一个唯一的任务ID。随后使用任务ID调用查询接口，获取任务状态和进度。任务完成后，从查询接口的响应中获取Markdown内容。
pub async fn post_web_tomarkdown_async(configuration: &configuration::Configuration, url: &str) -> Result<models::PostWebTomarkdownAsync202Response, Error<PostWebTomarkdownAsyncError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_url = url;

    let uri_str = format!("{}/web/tomarkdown/async", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("url", &p_query_url.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PostWebTomarkdownAsync202Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PostWebTomarkdownAsync202Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostWebTomarkdownAsyncError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

