/*
 * UAPI
 *
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_avatar_gravatar`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAvatarGravatarError {
    Status400(models::GetAvatarGravatar400Response),
    Status404(models::GetAvatarGravatar404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_image_bing_daily`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetImageBingDailyError {
    Status502(models::GetImageBingDaily502Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_image_motou`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetImageMotouError {
    Status400(models::GetImageMotou400Response),
    Status500(models::GetImageMotou500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_image_qrcode`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetImageQrcodeError {
    Status400(models::GetImageQrcode400Response),
    Status500(models::GetImageQrcode500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_image_tobase64`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetImageTobase64Error {
    Status400(models::GetImageTobase64400Response),
    Status502(models::GetImageTobase64502Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_image_compress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostImageCompressError {
    Status400(models::PostImageCompress400Response),
    Status500(models::PostImageCompress500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_image_frombase64`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostImageFrombase64Error {
    Status400(models::PostImageFrombase64400Response),
    Status500(models::PostImageFrombase64500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_image_motou`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostImageMotouError {
    Status400(models::PostImageMotou400Response),
    Status500(models::PostImageMotou500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_image_speechless`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostImageSpeechlessError {
    Status400(models::PostImageSpeechless400Response),
    Status500(models::PostImageSpeechless500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_image_svg`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostImageSvgError {
    Status400(models::PostImageSvg400Response),
    Status500(models::PostImageSvg500Response),
    UnknownValue(serde_json::Value),
}


/// 提供一个超高速、高可用的Gravatar头像代理服务。内置了强大的ETag条件缓存，确保用户在更新Gravatar头像后能几乎立刻看到变化，同时最大化地利用缓存。
pub async fn get_avatar_gravatar(configuration: &configuration::Configuration, email: Option<&str>, hash: Option<&str>, s: Option<i32>, d: Option<&str>, r: Option<&str>) -> Result<reqwest::Response, Error<GetAvatarGravatarError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_email = email;
    let p_query_hash = hash;
    let p_query_s = s;
    let p_query_d = d;
    let p_query_r = r;

    let uri_str = format!("{}/avatar/gravatar", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_email {
        req_builder = req_builder.query(&[("email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_hash {
        req_builder = req_builder.query(&[("hash", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_s {
        req_builder = req_builder.query(&[("s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_d {
        req_builder = req_builder.query(&[("d", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_r {
        req_builder = req_builder.query(&[("r", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAvatarGravatarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 每天都想换张新壁纸？让必应的美图点亮你的一天吧！  ## 功能概述 这个接口会获取 Bing 搜索引擎当天全球同步的每日壁纸，并直接以图片形式返回。你可以用它来做应用的启动页、网站背景，或者任何需要每日更新精美图片的地方。  ## 使用须知  > [!NOTE] > **响应格式是图片** > 请注意，此接口成功时直接返回图片二进制数据（通常为 `image/jpeg`），而非 JSON 格式。请确保客户端能够正确处理。  我们内置了备用方案：如果从必应官方获取图片失败，系统会尝试返回一张预存的高质量风景图，以保证服务的稳定性。
pub async fn get_image_bing_daily(configuration: &configuration::Configuration, ) -> Result<reqwest::Response, Error<GetImageBingDailyError>> {

    let uri_str = format!("{}/image/bing-daily", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetImageBingDailyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 想在线rua一下好友的头像吗？这个趣味接口可以满足你。  ## 功能概述 此接口通过GET方法，专门用于通过QQ号生成摸摸头GIF。你只需要提供一个QQ号码，我们就会自动获取其公开头像，并制作成一个可爱的动图。  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/gif` 格式的二进制数据。 - **背景颜色**：你可以通过 `bg_color` 参数来控制GIF的背景。使用 `transparent` 选项可以让它更好地融入各种聊天背景中。
pub async fn get_image_motou(configuration: &configuration::Configuration, qq: &str, bg_color: Option<&str>) -> Result<reqwest::Response, Error<GetImageMotouError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_qq = qq;
    let p_query_bg_color = bg_color;

    let uri_str = format!("{}/image/motou", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("qq", &p_query_qq.to_string())]);
    if let Some(ref param_value) = p_query_bg_color {
        req_builder = req_builder.query(&[("bg_color", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetImageMotouError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 无论是网址、文本还是联系方式，通通可以变成一个二维码！这是一个非常灵活的二维码生成工具。  ## 功能概述 你提供一段文本内容，我们为你生成对应的二维码图片。你可以自定义尺寸，并选择不同的返回格式以适应不同场景。  ## 使用须知  > [!IMPORTANT] > **关键参数 `format`** > 此参数决定了成功响应的内容类型和结构，请务必根据你的需求选择并正确处理响应： > - **`image`** (默认): 直接返回 `image/png` 格式的图片二进制数据，适合在 `<img>` 标签中直接使用。 > - **`json`**: 返回一个包含 Base64 Data URI 的 JSON 对象，适合需要在前端直接嵌入CSS或HTML的场景。 > - **`json_url`**: 返回一个包含图片临时URL的JSON对象，适合需要图片链接的场景。
pub async fn get_image_qrcode(configuration: &configuration::Configuration, text: &str, size: Option<i32>, format: Option<&str>) -> Result<reqwest::Response, Error<GetImageQrcodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_text = text;
    let p_query_size = size;
    let p_query_format = format;

    let uri_str = format!("{}/image/qrcode", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("text", &p_query_text.to_string())]);
    if let Some(ref param_value) = p_query_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetImageQrcodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 看到一张网上的图片，想把它转换成 Base64 编码以便嵌入到你的 HTML 或 CSS 中？用这个接口就对了。  ## 功能概述 你提供一个公开可访问的图片 URL，我们帮你把它下载下来，并转换成包含 MIME 类型的 Base64 Data URI 字符串返回给你。
pub async fn get_image_tobase64(configuration: &configuration::Configuration, url: &str) -> Result<models::GetImageTobase64200Response, Error<GetImageTobase64Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_url = url;

    let uri_str = format!("{}/image/tobase64", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("url", &p_query_url.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetImageTobase64200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetImageTobase64200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetImageTobase64Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 还在为图片体积和加载速度发愁吗？体验一下我们强大的**无损压缩服务**，它能在几乎不牺牲任何肉眼可感知的画质的前提下，将图片体积压缩到极致。  ## 功能概述 你只需要上传一张常见的图片（如 PNG, JPG），选择一个压缩等级，就能获得一个体积小到惊人的压缩文件。这对于需要大量展示高清图片的网站、App 或小程序来说，是优化用户体验、节省带宽和存储成本的利器。  ## 使用须知 > [!TIP] > 为了给您最好的压缩效果，我们的算法需要进行复杂计算，处理时间可能会稍长一些，请耐心等待。  > [!WARNING] > **服务排队提醒** > 这是一个计算密集型服务。在高并发时，您的请求可能会被排队等待处理。如果您需要将其集成到对延迟敏感的生产服务中，请注意这一点。  ### 请求与响应格式 - 请求必须使用 `multipart/form-data` 格式上传文件。 - 成功响应将直接返回压缩后的文件二进制流 (`application/octet-stream`)，并附带 `Content-Disposition` 头，建议客户端根据此头信息保存文件。  ## 参数详解 ### `level` (压缩等级) 这是一个从 `1` 到 `5` 的整数，它决定了压缩的强度和策略，数字越小，压缩率越高。所有等级都经过精心调校，以在最大化压缩率的同时保证出色的视觉质量。 - `1`: **极限压缩** (推荐，体积最小，画质优异) - `2`: **高效压缩** - `3`: **智能均衡** (默认选项) - `4`: **画质优先** - `5`: **专业保真** (压缩率稍低，保留最多图像信息)  ## 错误处理指南 - **400 Bad Request**: 通常因为没有上传文件，或者 `level` 参数不在 1-5 的范围内。 - **500 Internal Server Error**: 如果在压缩过程中服务器发生内部错误，会返回此状态码。
pub async fn post_image_compress(configuration: &configuration::Configuration, file: std::path::PathBuf, level: Option<i32>, format: Option<&str>) -> Result<reqwest::Response, Error<PostImageCompressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_file = file;
    let p_query_level = level;
    let p_query_format = format;

    let uri_str = format!("{}/image/compress", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_level {
        req_builder = req_builder.query(&[("level", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'file' parameter
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<PostImageCompressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 当你需要在前端处理完图片（比如裁剪、加滤镜后），不通过传统表单，而是直接上传图片的场景，这个接口就派上用场了。  ## 功能概述 你只需要将图片的 Base64 编码字符串发送过来，我们就会把它解码、保存为图片文件，并返回一个可供访问的公开 URL。  ## 使用须知  > [!IMPORTANT] > **关于 `imageData` 格式** > 你发送的 `imageData` 字符串必须是完整的 Base64 Data URI 格式，它需要包含 MIME 类型信息，例如 `data:image/png;base64,iVBORw0KGgo...`。缺少 `data:image/...;base64,` 前缀将导致解码失败。
pub async fn post_image_frombase64(configuration: &configuration::Configuration, post_image_frombase64_request: models::PostImageFrombase64Request) -> Result<models::PostImageFrombase64200Response, Error<PostImageFrombase64Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_post_image_frombase64_request = post_image_frombase64_request;

    let uri_str = format!("{}/image/frombase64", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_post_image_frombase64_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PostImageFrombase64200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PostImageFrombase64200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostImageFrombase64Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 除了使用QQ头像，你还可以通过上传自己的图片或提供图片URL来制作独一无二的摸摸头GIF。  ## 功能概述 此接口通过POST方法，支持两种方式生成GIF： 1.  **图片URL**：在表单中提供 `image_url` 字段。 2.  **上传图片**：在表单中上传 `file` 文件。  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/gif` 格式的二进制数据。 - **参数优先级**：如果同时提供了 `image_url` 和上传的 `file` 文件，系统将 **优先使用 `image_url`**。 - **背景颜色**：同样支持 `bg_color` 表单字段来控制GIF背景。
pub async fn post_image_motou(configuration: &configuration::Configuration, image_url: Option<&str>, file: Option<std::path::PathBuf>, bg_color: Option<&str>) -> Result<reqwest::Response, Error<PostImageMotouError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_image_url = image_url;
    let p_form_file = file;
    let p_form_bg_color = bg_color;

    let uri_str = format!("{}/image/motou", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form = reqwest::multipart::Form::new();
    if let Some(param_value) = p_form_image_url {
        multipart_form = multipart_form.text("image_url", param_value.to_string());
    }
    // TODO: support file upload for 'file' parameter
    if let Some(param_value) = p_form_bg_color {
        multipart_form = multipart_form.text("bg_color", param_value.to_string());
    }
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<PostImageMotouError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 你们怎么不说话了？是不是都在偷偷玩Uapi，求求你们不要玩Uapi了  ## 效果展示 ![示例](https://uapis.cn/static/uploads/33580466897f1e5815296f235b582815.png)  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/jpeg` 格式的二进制数据。 - **文字内容**：至少需要提供 `top_text`（上方文字）或 `bottom_text`（下方文字）之一。 - **梗图逻辑**：上方描述某个行为，下方通常以「们」开头表示劝阻，形成戏谑的对比效果。
pub async fn post_image_speechless(configuration: &configuration::Configuration, post_image_speechless_request: models::PostImageSpeechlessRequest) -> Result<reqwest::Response, Error<PostImageSpeechlessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_post_image_speechless_request = post_image_speechless_request;

    let uri_str = format!("{}/image/speechless", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_post_image_speechless_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<PostImageSpeechlessError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 需要将灵活的 SVG 矢量图形转换为常见的光栅图像格式吗？这个接口可以帮你轻松实现。  ## 功能概述 上传一个 SVG 文件，并指定目标格式（如 PNG、JPEG 等），接口将返回转换后的图像。你还可以调整输出图像的尺寸和（对于JPEG）压缩质量，以满足不同场景的需求。
pub async fn post_image_svg(configuration: &configuration::Configuration, format: Option<&str>, width: Option<i32>, height: Option<i32>, quality: Option<i32>, file: Option<std::path::PathBuf>) -> Result<reqwest::Response, Error<PostImageSvgError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_format = format;
    let p_query_width = width;
    let p_query_height = height;
    let p_query_quality = quality;
    let p_form_file = file;

    let uri_str = format!("{}/image/svg", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_width {
        req_builder = req_builder.query(&[("width", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_height {
        req_builder = req_builder.query(&[("height", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_quality {
        req_builder = req_builder.query(&[("quality", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'file' parameter
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<PostImageSvgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

